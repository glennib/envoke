use std::fmt::Write as _;
use std::fs;
use std::path::PathBuf;

use anyhow::Context;
use clap::Parser;
use tracing_subscriber::EnvFilter;

mod config;
mod error;
mod resolve;

#[derive(Parser)]
#[command(about = "Resolve environment variables from envoke.yaml")]
struct Cli {
    /// Target environment (e.g. local, apps-prod).
    #[arg(required_unless_present = "schema")]
    environment: Option<String>,

    /// Write output to a file instead of stdout.
    #[arg(short, long)]
    output: Option<PathBuf>,

    /// Only include tagged variables with a matching tag. Repeatable.
    /// Untagged variables are always included.
    #[arg(short = 't', long = "tag")]
    tags: Vec<String>,

    /// Select named overrides for source selection. Repeatable.
    /// Per variable, at most one active override may be defined.
    #[arg(short = 'O', long = "override")]
    overrides: Vec<String>,

    /// Prefix each line with `export `.
    #[arg(long)]
    prepend_export: bool,

    /// Path to config file.
    #[arg(short, long, default_value = "envoke.yaml")]
    config: PathBuf,

    /// Print the JSON Schema for envoke.yaml and exit.
    #[arg(long)]
    schema: bool,
}

/// Escape a value for safe inclusion in a single-quoted shell string.
///
/// Embedded single quotes are replaced with `'\''` (end quote, escaped quote,
/// start quote).
fn shell_escape(value: &str) -> String {
    value.replace('\'', "'\\''")
}

fn run() -> anyhow::Result<()> {
    tracing_subscriber::fmt()
        .with_writer(std::io::stderr)
        .with_env_filter(EnvFilter::from_default_env())
        .init();

    let cli = Cli::parse();

    if cli.schema {
        let schema = schemars::schema_for!(config::Config);
        let json = serde_json::to_string_pretty(&schema).context("failed to serialize schema")?;
        println!("{json}");
        return Ok(());
    }

    // Default: generate
    {
        let tags = cli.tags;
        let overrides = cli.overrides;
        let environment = cli.environment.expect("required by clap");
        let output = cli.output;
        let prepend_export = cli.prepend_export;

        let yaml = fs::read_to_string(&cli.config)
            .with_context(|| format!("failed to read {}", cli.config.display()))?;
        let config: config::Config =
            serde_yaml::from_str(&yaml).context("failed to parse envoke.yaml")?;

        eprintln!("Generating environment variables for {environment}...");

        let resolved =
            resolve::resolve_all(&config, &environment, &tags, &overrides).map_err(|errors| {
                for err in &errors {
                    eprintln!("error: {err}");
                }
                anyhow::anyhow!("{} variable(s) failed to resolve", errors.len())
            })?;

        let export_prefix = if prepend_export { "export " } else { "" };

        let mut body = String::new();
        for var in &resolved {
            if let Some(desc) = &var.description {
                let _ = writeln!(body, "# {desc}");
            }
            let escaped = shell_escape(&var.value);
            let _ = writeln!(body, "{export_prefix}{}='{escaped}'", var.name);
        }

        if let Some(path) = &output {
            let invocation: Vec<_> = std::env::args().collect();
            let timestamp = chrono::Local::now().to_rfc3339();
            let header = format!(
                "# @generated by `{}` at {timestamp}\n# Do not edit manually. Modify envoke.yaml \
                 instead.\n\n",
                invocation.join(" ")
            );
            let content = format!("{header}{body}");
            fs::write(path, &content)
                .with_context(|| format!("failed to write {}", path.display()))?;
            eprintln!("Wrote to {}", path.display());
        } else {
            print!("{body}");
        }

        Ok(())
    }
}

fn main() -> anyhow::Result<()> {
    run()
}
